{"pages":[{"url":"/pages/about.html","text":"Coming soon","tags":"pages","title":"About"},{"url":"/pages/project.html","text":"Coming soon","tags":"pages","title":"Project"},{"url":"/object-oriented-python.html","text":"0. Old style vs new style class Up to Python 2.1, old-style classes were the only flavour available to the user. The concept of (old-style) class is unrelated to the concept of type: if x is an instance of an old-style class, then x. class designates the class of x, but type(x) is always . This reflects the fact that all old-style instances, independently of their class, are implemented with a single built-in type, called instance. For old-style classes (the only flavour of classes up to Python 2.1), have the following property : If x is an instance of the class, then x.__class__ designates the class of x. However, type(x) will always return instance . New-style classes, introduced in Python 2.2, unify the concepts of class and type. Calling type(x) or x.__class__ will return the same thing (unless you override it). The major motivation for introducing new-style classes is to provide a unified object model with a full meta-model. It also has a number of immediate benefits, like the ability to subclass most built-in types, or the introduction of \"descriptors\", which enable computed properties. In Python 2.7, classes are still old-style by default. New-style classes are created by inheriting from a new-style class or from object . New-style classes introduce a couple of important changes : the super() function (more later), descriptors, or the order in which functions are looked-up in case of multiple inheritance. In short, you get : 1 2 3 4 5 6 7 8 9 class NewStyleClass ( object ): pass class AnotherNewStyleClass ( NewStyleClass ): pass Old - style classes don 't. class OldStyleClass (): pass Python 3 only has new-style classes, whether you subclass from object or not. 1. Overloading It is possible to overload common operators, like + in this case by redefining the relevant function ( add () in this case). 1 2 3 4 5 6 7 class TestOverloading (): def __init__ ( self , a ): self . _val = a def __add__ ( self , b ): return self . _val * b . _val 1 2 3 4 > a = TestOverloading(2) > b = TestOverloading(3) > print a+b > 6 2. Inheritance 1 2 3 4 5 6 7 class Base ( object ): def __init__ ( self ): print \"1\" class Child ( Base ): def __init__ ( self ): super ( Child , self ) . __init__ () Super indicates that we use the inherited __init__ method N.B. The base class needs to inherit from object 3. Overriding Base class functions 1 2 3 4 5 6 7 8 9 class Base (): def _method (): # do things class Child ( Base ): def _method (): # do other things # this overrides the base class _method 4. Abstract Base Classes A class is an abstract base class (ABC) if its only purpose is to serve as a base class through inheritance. An ABC cannot be instantiated. from abc import ABCMeta, abstractmethod need these definitions 5. Using super N.B. super only works with new style classes. This part relies heavily on this stack thred . In a class hierarchy with single inheritance, super can be used to refer to parent classes without naming them explicitly, thus making the code more maintainable. Let's give an example : 1 2 3 4 5 6 7 class ChildA ( Base ): def __init__ ( self ): Base . __init__ ( self ) class ChildB ( Base ): def __init__ ( self ): super ( ChildB , self ) . __init__ () In the case of simple inheritance, these two chunks of codes achieve the same thing (i.e. showing the ChildA and ChildB explicitly inherit the __init__ method from Base ). However, were we to change the name of Base , we would have to change it everywhere it was used to specify inheritance. The second use case is to support cooperative multiple inheritance. Once again, let's use an example to illustrate. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class SomeBaseClass ( object ): def __init__ ( self ): print ( 'SomeBaseClass.__init__(self) called' ) class Child ( SomeBaseClass ): def __init__ ( self ): print ( 'Child.__init__(self) called' ) SomeBaseClass . __init__ ( self ) class SuperChild ( SomeBaseClass ): def __init__ ( self ): print ( 'SuperChild.__init__(self) called' ) super ( SuperChild , self ) . __init__ () class InjectMe ( SomeBaseClass ): def __init__ ( self ): print ( 'InjectMe.__init__(self) called' ) super ( InjectMe , self ) . __init__ () class UnsuperInjector ( Child , InjectMe ): pass class SuperInjector ( SuperChild , InjectMe ): pass Let's look at the results : 1 2 3 4 5 6 7 8 >>> o = UnsuperInjector() Child.__init__(self) called SomeBaseClass.__init__(self) called >>> o2 = SuperInjector() SuperChild.__init__(self) called InjectMe.__init__(self) called SomeBaseClass.__init__(self) called So we see that the dependency on InjectMe is only taken into account through the use of super . Using super , we can inject a class ( InjectMe ) between two other classes ( Child and SomeBaseClass ). This gives you a way of influencing the behaviour of the SuperInjector class without modifying the code of the base class.","tags":"Python","title":"Object oriented Python"},{"url":"/aws-part-3-installing-python-and-custom-ami.html","text":"1. Launch an Amazon instance Launch an Amazon instance corresponding to your needs. For more information, check AWS Part 1 . 2. Install python software Once the instance is running, SSH to it as seen in AWS Part 1 . Download Anaconda with wget : wget https://3230d63b5fc54e62148e-c95ac804525aac4b6dba79b00b39d1d3.ssl.cf1.rackcdn.com/Anaconda2-2.4.1-Linux-x86_64.sh Install Anaconda : bash Anaconda2-2.4.1-Linux-x86_64.sh In case you need permission, just append sudo to each command Accept the conditions and the installation should start. When Anaconda asks whether you want to prepend its path to your $PATH variable, type yes. Reload your .bashrc source .bashrc If everything worked, you should see the following messages when calling python 1 2 3 4 5 Python 2.7.11 |Anaconda 2.4.1 (64-bit)| (default, Dec 6 2015, 18:08:32) [GCC 4.4.7 20120313 (Red Hat 4.4.7-1)] on linux2 Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. Anaconda is brought to you by Continuum Analytics. Please check out: http://continuum.io/thanks and https://anaconda.org You can now import classic modules such as numpy, pandas etc. 3. Create an AMI for this instance In the AWS console, select the instance you just launched Actions => Image => Create Image . Give a name and a description to your instance, then Create Image . By default, Amazon will reboot your instance. You can choose not too by ticking the No Reboot window. The system is going down for reboot NOW! Control-Alt-Delete pressed Connection to ec2-52-62-15-17.ap-southeast-2.compute.amazonaws.com closed by remote host. Connection to ec2-52-62-15-17.ap-southeast-2.compute.amazonaws.com closed. By checking on the AMI pane in the console, you should see your image being created. You can now launch an instance from your new AMI. It contains all the packages that we installed in step 2.","tags":"AWS","title":"AWS Part 3 : Installing python and custom AMI"},{"url":"/aws-part-2-ec2-instances.html","text":"1. Launch an instance Connect to the Amazon EC2 console Go to the EC2 dashboard , click on Launch instance . Then select the Ubuntu Server AMI. Stick to the t2.micro instance (free tier eligible). Go to Configure Security Group and select the group we configured in AWS Part 1 . We are ready to Launch Select the key pair we created in AWS Part 1 when prompted. A new key pair can also be created. Click Launch Instances N.B. Don't select the Proceed without a key pair option. If you launch your instance without a key pair, then you can't connect to it. N.B. It can take some time for the instance to launch. Review its status in Status Checks column. 2. Connect to your instance with an SSH Verify an SSH client is installed on your computer Install Amazon CLI tools. Download the tools from this link 1 wget http://s3.amazonaws.com/ec2-downloads/ec2-api-tools.zip And unzip in a suitable directory 1 2 sudo mkdir /usr/local/ec2 sudo unzip ec2-api-tools.zip -d /usr/local/ec2 Install and configure JAVA The Amazon EC2 CLI tools require Java. You can check Java is installed by running 1 which java which should yield something like : 1 /usr/bin/java If that is not the case, install java as indicated here . We now need to find the Java home directory. The which command we executed earlier returns Java's location in the $PATH environment variable but most of the time, it's a symbolic link. You can check this by running : 1 file $(which java) which in my case returns : 1 /usr/bin/java: symbolic link to `/etc/alternatives/java' by iterating the file command, you can find the true java home directory : 1 2 file /etc/alternatives/java > /etc/alternatives/java: symbolic link to `/usr/lib/jvm/java-8-oracle/jre/bin/java' the last location is the actual binary, which you can check by running : 1 2 file /usr/lib/jvm/java-8-oracle/jre/bin/java > /usr/lib/jvm/java-8-oracle/jre/bin/java: ELF 64-bit LSB executable In this example, the java home directory is : 1 /usr/lib/jvm/java-8-oracle/jre/ We are now going to set the JAVA_HOME variable to the home directory we identified : 1 export JAVA_HOME=\"/usr/lib/jvm/java-8-oracle/jre/\" To check this has been set correctly, use : 1 $ JAVA_HOME /bin/java -version which should get you : 1 2 3 java version \"1.8.0_66\" Java(TM) SE Runtime Environment (build 1.8.0_66-b17) Java HotSpot(TM) 64-Bit Server VM (build 25.66-b17, mixed mode) Add this variable definition to your .bashrc so that JAVA_HOME is defined whenever you spawn a new shell. Set the CLI Tools location The Amazon EC2 CLI tools read the EC2_HOME environment variable to locate supporting libraries. Before using these tools, set EC2_HOME to the directory path where you unzipped them. In your .bashrc, write : 1 export EC2_HOME=\"/usr/local/ec2/ec2-api-tools-1.7.5.1\" where the version number are specific to the version you downloaded. To get the right numbers, use : 1 ls /usr/local/ec2 We will also add the bin directory for the CLI tools to our system path. 1 export PATH=\" $ PATH : $ EC2_HOME /bin\" Set your identity for the CLI Tools Your access keys identify you to the Amazon EC2 CLI tools. There are two types of access keys: access key IDs (for example, AKIAIOSFODNN7EXAMPLE) and secret access keys (for example, wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY). You should have stored your access keys in a safe place when you received them. We will set the following environment variable which will serve as default values for the access and secret keys. This will save you from entering your keys for each command. 1 2 export AWS_ACCESS_KEY=your-aws-access-key-id export AWS_SECRET_KEY=your-aws-secret-key We can check that the keys have been properly set 1 ec2-describe-regions Which should yield something like : 1 2 3 4 5 6 7 8 9 >REGION eu-west-1 ec2.eu-west-1.amazonaws.com >REGION ap-southeast-1 ec2.ap-southeast-1.amazonaws.com >REGION ap-southeast-2 ec2.ap-southeast-2.amazonaws.com >REGION eu-central-1 ec2.eu-central-1.amazonaws.com >REGION ap-northeast-1 ec2.ap-northeast-1.amazonaws.com >REGION us-east-1 ec2.us-east-1.amazonaws.com >REGION sa-east-1 ec2.sa-east-1.amazonaws.com >REGION us-west-1 ec2.us-west-1.amazonaws.com >REGION us-west-2 ec2.us-west-2.amazonaws.com Change the region (if needed) The default EC2 CLI region is US East (us-east-1). To change this region, you need to set the following environment variable 1 export EC2_URL=https://<service_endpoint> where the service endpoint is something like ec2.region.amazonaws.com (cf ec2-describe-regions ). Connect via SSH In a terminal, go to the location of the private key file (.pem) used when launching the instance. In a command line shell, change directories to the location of the private key file that you created when you launched the instance. The SSH command should be something like : 1 ssh -i /path/my-key-pair.pem user_name@public_dns_name where use name is ubuntu for an ubuntu AMI and the public dns name is specified in the AWS console. Alternatively, the dns name can be found using 1 ec2-describe-instances For instance : 1 ssh -i /path/my-key-pair.pem ubuntu@ec2-52-62-114-212.ap-southeast-2.compute.amazonaws.com When prompted, enter yes. You should get something like : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Welcome to Ubuntu 14.04.2 LTS (GNU/Linux 3.13.0-48-generic x86_64) * Documentation: https://help.ubuntu.com/ System information as of Sun Jan 3 07:11:31 UTC 2016 System load: 0.0 Memory usage: 5% Processes: 82 Usage of /: 9.8% of 7.74GB Swap usage: 0% Users logged in: 0 Graph this data and manage this system at: https://landscape.canonical.com/ Get cloud support with Ubuntu Advantage Cloud Guest: http://www.ubuntu.com/business/services/cloud 0 packages can be updated. 0 updates are security updates. The programs included with the Ubuntu system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. Congrats, you are now connected ! You can transfer files easily with the scp command : 1 scp -i /path/my-key-pair.pem myfile ubuntu@ec2-52-62-114-212.ap-southeast-2.compute.amazonaws.com:~ 3. Close your an instance Select your instance in the AWS console. Actions , Instance State , Terminate . Choose Yes, Terminate .","tags":"AWS","title":"AWS Part 2 : EC2 instances"},{"url":"/aws-part-1-setting-up-amazon-ec2.html","text":"1. Setup your account Start by signing up for an AWS account. Choose the free tier option : you won't be billed for 12 months given you do not exceed certain limits ! You will have to provide credit card information and a phone number. 2. Setup your user IAM What is IAM ? AWS Identity and Access Management (IAM) is a web service that helps you securely control access to AWS resources for your users. You use IAM to control who can use your AWS resources (authentication) and what resources they can use and in what ways (authorization). Amazon advises you against using your AWS account credentials to access AWS because the root account provides unrestricted access to your AWS resources. The preferred procedure is to for you to create and use an IAM user to whom you grant administrative permissions. Then you can access AWS with a special URL + IAM user credentials. To create a new IAM user : Create a group of administrators Open the IAM console Groups => Create New Group => Set Administrators as name (for instance) and click Next . In the policy list , tick the AdministratorAccess box => Next Step => Create Group . Voila ! Instructions as gif below: Create an IAM user for yourself Users => Create New Users => Set you username => Clear the box next to \"Generate an access key\" => Create . In the list of users , click on the newly created user. In the Groups tab, => Add User to Groups . Tick the checkbox near your group of administrators => Add to Groups . In the Security credentials tab => click Manage password => Assign a custom password . Confirm password => Apply . Voila ! To sign in as the IAM user : Sign out Go to the following URL : https://aws_id.signin.aws.amazon.com/console/ (your AWS ID is a 12 number ID which you can find in your account settings) Enter your IAM username and password You should now be signed in as : your_user_name @ your_aws_account_id . Instead of using your AWS ID, you can create an alias : IAM Dashboard => Customize => Enter your alias. You can now sign in with : - https://your_alias.signin.aws.amazon.com/console/ You should now see (in the IAM Dashboard ) that your IAM users sign-in link has indeed been changed to: - https://your_alias.signin.aws.amazon.com/console More information on IAM . 3. Create a Key Pair AWS uses public-key cryptography to secure the login information for your instance. A Linux instance has no password; you use a key pair to log in to your instance securely. You specify the name of the key pair when you launch your instance, then provide the private key when you log in using SSH. N.B. You need a key pair per region (if you launch instances in multiple regions). To create a key pair Sign in with your user IAM URL Select any region from the navigation bar => Key Pairs => Create Key Pair . Enter a name for your key pair (e.g. alias-key-pair-sydney) => Create . You automatically download the private key in a PEM file. Save it in a safe place N.B. This is the only chance to save the file. You will need to give your key pair name + corresponding private key each time you connect to the instance. If you connect by SSH to your Linux instance, in the directory where you put your private key: $ chmod 400 your_user_name-key-pair-region_name.pem to set the permissions of the private key file so that only you can read it. More information on Key Pair To connect to your instance using your key pair To connect to your Linux instance from a computer running Mac or Linux, you'll specify the .pem file to your SSH client with the -i option and the path to your private key. Open the Amazon EC2 console console 4. Create a security group Security groups act as a firewall for associated instances, controlling both inbound and outbound traffic at the instance level. Prerequisite You will need the public IP address of your computer. Type this command in a terminal to access your public IP address : curl -s http://checkip.amazonaws.com/ To create a security group with least privilege Go to the EC2 dashboard. Select Security Groups . Create Security Group . Give it a name and a description. Choose a VPC (the default one has a * symbol). On the Inbound tab, add the following access rules : HTTP, set Source to anywhere . HTTP, set Source to anywhere . SSH, set Source to your public IP in CIDR notation. Then click on Create . N.B. If your IP address is 203.0.113.25, then its CIDR notation is 203.0.113.25/32. What we've done here is allowing web servers to receive all inbound HTTP and HTTPS traffic as well as allowing SSH connection from your computer. More information on network security .","tags":"AWS","title":"AWS Part 1 : Setting up Amazon EC2"}]}